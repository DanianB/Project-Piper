<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Piper Hub</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Piper</h1>
        <div class="sub">
          <span>Local assistant</span>
          <a href="/ping" target="_blank" rel="noopener">/ping</a>
        </div>
      </div>

      <div class="pills">
        <label class="pill">
          <input id="readOnly" type="checkbox" />
          <span>Read-only</span>
        </label>

        <!-- Voice menu -->
        <div class="voiceWrap">
          <button id="voiceBtn" class="btn-secondary btn-voice" type="button">ðŸ”Š Voice</button>
          <div id="voicePanel" class="voicePanel" style="display:none">
            <div class="voiceRow">
              <div class="voiceLabel">Voice</div>
              <select id="voiceSelect" class="voiceSelect"></select>
            </div>

            <div class="voiceRow voiceRowTight">
              <label class="pill" style="margin:0">
                <input id="jarvisMode" type="checkbox" />
                <span>JARVIS mode</span>
              </label>
              <button id="voiceRefresh" class="btn-secondary btn-voiceRefresh" type="button" title="Refresh voice selection">â†»</button>
            </div>

            <div class="voiceHint">
              <div>â€¢ Amy/Jarvis use <code>piper.exe</code></div>
              <div>â€¢ Piper uses <code>chatterbox</code></div>
              <div style="opacity:.8;margin-top:6px;">If audio fails, open DevTools Console.</div>
            </div>
          </div>
        </div>

        <button id="talk" class="btn-primary">ðŸŽ¤ Talk</button>
        <button id="off" class="btn-danger">ðŸ›‘ Off</button>
      </div>
    </div>

    <div class="panel">
      <div id="log"></div>

      <form id="f">
        <input id="t" type="text" placeholder="Type a messageâ€¦" autocomplete="off" />
        <button class="btn-primary">Send</button>
      </form>
    </div>

    <div id="actionsWrap" class="section panel" style="display:none">
      <div class="sectionHeader">
        <h3>Pending Actions</h3>
        <div class="hint">Approve to execute. Preview shows what will change.</div>
      </div>
      <div id="actionsList"></div>
    </div>

    <div id="history" class="section panel">
      <details open>
        <summary class="sectionSummary">
          <span style="font-weight:700">Recent Actions</span>
          <span class="hint">Latest 10</span>
        </summary>
        <div id="historyList"></div>
      </details>
    </div>
  </div>

<script>
const log = document.getElementById('log');
const f = document.getElementById('f');
const t = document.getElementById('t');
const talk = document.getElementById('talk');
const off = document.getElementById('off');
const readOnly = document.getElementById('readOnly');

const actionsWrap = document.getElementById("actionsWrap");
const actionsList = document.getElementById("actionsList");
const historyList = document.getElementById("historyList");

// Voice UI
const voiceBtn = document.getElementById("voiceBtn");
const voicePanel = document.getElementById("voicePanel");
const voiceSelect = document.getElementById("voiceSelect");
const jarvisMode = document.getElementById("jarvisMode");
const voiceRefresh = document.getElementById("voiceRefresh");

const sessionId = localStorage.getItem("piper_sessionId") || (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
localStorage.setItem("piper_sessionId", sessionId);

// Persist <details> open state per action id
const openDetails = new Set(JSON.parse(localStorage.getItem("piper_openDetails") || "[]"));

// Hard-coded voice choices (provider + voice)
const VOICE_CHOICES = [
  { id: "amy",    label: "Amy",    provider: "piper",      voice: "amy" },
  { id: "jarvis", label: "Jarvis", provider: "piper",      voice: "jarvis" },
  { id: "piper",  label: "Piper",  provider: "chatterbox", voice: "default" },
];

function choiceById(id){
  return VOICE_CHOICES.find(v => v.id === id) || VOICE_CHOICES[0];
}

// Voice state
let lastNonJarvisVoice = localStorage.getItem("piper_lastNonJarvisVoice") || "";

function hookDetailsPersistence(cardEl, actionId){
  const details = cardEl.querySelectorAll("details[data-kind]");
  details.forEach(d => {
    const key = `${actionId}:${d.getAttribute("data-kind")}`;
    if(openDetails.has(key)) d.open = true;

    d.addEventListener("toggle", () => {
      if(d.open) openDetails.add(key);
      else openDetails.delete(key);
      localStorage.setItem("piper_openDetails", JSON.stringify(Array.from(openDetails)));
    }, { passive: true });
  });
}

function badgeClass(status){
  return ["pending","running","done","failed","rejected","rolled_back","approved"].includes(status) ? status : "pending";
}
function fmtTime(ms){
  try { return new Date(ms).toLocaleString(); } catch { return ""; }
}
function esc(s){ return String(s).replaceAll("<","&lt;"); }

function add(who, msg, meta){
  const row = document.createElement('div');
  row.className = 'msg ' + who;

  const whoEl = document.createElement('div');
  whoEl.className = 'who';
  whoEl.textContent = who === 'me' ? 'You' : 'Piper';

  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  bubble.innerHTML = String(msg).replaceAll('\n','<br>');

  if(meta){
    const m = document.createElement('div');
    m.className = 'metaLine';
    m.textContent = meta;
    bubble.appendChild(m);
  }

  row.appendChild(whoEl);
  row.appendChild(bubble);
  log.appendChild(row);
  log.scrollTop = log.scrollHeight;
  return row;
}

function remove(node){
  try{ node && node.remove && node.remove(); }catch{}
}

async function api(path, body){
  const r = await fetch(path,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body||{})
  });
  const j = await r.json().catch(()=>null);
  if(!r.ok) throw new Error((j && (j.error||j.message)) || (r.status+" "+r.statusText));
  return j;
}

// Speak helper: DO NOT swallow errors
async function speak(text){
  try{
    const r = await fetch('/voice/speak',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({ text: String(text || "") })
    });
    if(!r.ok){
      const body = await r.text().catch(()=>"(no body)");
      console.warn("/voice/speak failed:", r.status, body);
    }
  }catch(e){
    console.warn("/voice/speak error:", e);
  }
}

// ---- Voice UI logic ----
async function fetchVoiceConfig(){
  const r = await fetch("/voice/config", { cache: "no-store" });
  const j = await r.json().catch(()=>null);
  if(!r.ok) throw new Error("Failed to load voice config.");

  // Accept either:
  // 1) { provider, voice, ... }   (your current backend GET returns this)
  // 2) { ok:true, config:{...} }  (older wrapper format)
  if(j && j.ok && j.config) return j.config;
  if(j && typeof j === "object" && (("provider" in j) || ("voice" in j))) return j;

  throw new Error("Failed to load voice config.");
}

function fillVoiceSelect(selectedId){
  voiceSelect.innerHTML = "";
  for(const v of VOICE_CHOICES){
    const opt = document.createElement("option");
    opt.value = v.id;
    opt.textContent = v.label;
    voiceSelect.appendChild(opt);
  }
  voiceSelect.value = VOICE_CHOICES.some(v => v.id === selectedId) ? selectedId : VOICE_CHOICES[0].id;
}

async function applyVoice(choiceId){
  const c = choiceById(choiceId);

  const out = await api("/voice/config", { provider: c.provider, voice: c.voice });
  const provider = out?.config?.provider || c.provider;
  const voice = out?.config?.voice || c.voice;

  voiceBtn.textContent = `ðŸ”Š ${c.label}`;
  jarvisMode.checked = (provider === "piper" && voice === "jarvis");

  if(!(provider === "piper" && voice === "jarvis")){
    lastNonJarvisVoice = choiceId;
    localStorage.setItem("piper_lastNonJarvisVoice", lastNonJarvisVoice);
  }
}

async function initVoiceUI(){
  try{
    const cfg = await fetchVoiceConfig();
    let selected = "amy";
    if(cfg.provider === "piper" && cfg.voice === "jarvis") selected = "jarvis";
    if(cfg.provider === "chatterbox") selected = "piper";

    fillVoiceSelect(selected);
    voiceBtn.textContent = `ðŸ”Š ${choiceById(selected).label}`;
    jarvisMode.checked = (selected === "jarvis");
  }catch(e){
    console.warn("voice ui init failed", e);
    fillVoiceSelect("amy");
    voiceBtn.textContent = "ðŸ”Š Amy";
    jarvisMode.checked = false;
  }
}

// Open/close menu
voiceBtn.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  const open = voicePanel.style.display !== 'none';
  voicePanel.style.display = open ? 'none' : 'block';
};

document.addEventListener("click", (e) => {
  if(!voicePanel) return;
  if(voicePanel.style.display === "none") return;
  const vw = voiceBtn.closest(".voiceWrap");
  if(vw && !vw.contains(e.target)){
    voicePanel.style.display = 'none';
  }
});

voiceRefresh.onclick = async () => {
  try{
    const cfg = await fetchVoiceConfig();
    let selected = "amy";
    if(cfg.provider === "piper" && cfg.voice === "jarvis") selected = "jarvis";
    if(cfg.provider === "chatterbox") selected = "piper";

    fillVoiceSelect(selected);
    voiceBtn.textContent = `ðŸ”Š ${choiceById(selected).label}`;
    jarvisMode.checked = (selected === "jarvis");
  }catch(e){
    alert("Failed to refresh voices: " + e);
  }
};

voiceSelect.onchange = async () => {
  try{ await applyVoice(voiceSelect.value); }
  catch(e){ alert("Failed to set voice: " + e); }
};

jarvisMode.onchange = async () => {
  if(jarvisMode.checked){
    voiceSelect.value = "jarvis";
    await applyVoice("jarvis");
  } else {
    const restore = lastNonJarvisVoice || "amy";
    voiceSelect.value = restore;
    await applyVoice(restore);
  }
};

// ---- Actions (match your backend) ----
async function fetchAllActions(){
  const r = await fetch("/actions", { cache: "no-store" });
  const j = await r.json().catch(()=>null);
  if(!(j && j.ok && Array.isArray(j.actions))) throw new Error("Failed to load actions.");
  return j.actions;
}

function renderPending(pending){
  actionsWrap.style.display = pending.length ? "block" : "none";
  actionsList.innerHTML = "";

  for(const a of pending){
    const d = document.createElement("div");
    d.className = "card";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const reason = a.reason ? a.reason : "";
    const canPreview = ["apply_patch","write_file","mkdir","bundle","set_html_title"].includes(a.type);
    const previewHref = "/action/preview/" + a.id;

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Created: ${fmtTime(a.createdAt)}</span>
      </div>

      ${reason ? `<div class="kv" style="margin-top:6px;"><span><b>Why:</b> ${esc(reason)}</span></div>` : ``}

      <details data-kind="payload">
        <summary>View details</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      <div class="btnRow">
        <button class="btn-primary" data-act="approve">Approve</button>
        <button class="btn-secondary" data-act="reject">Reject</button>
        ${canPreview ? `<a class="btn-secondary" href="${previewHref}" target="_blank" rel="noopener">Preview</a>` : ``}
      </div>
    `;

    hookDetailsPersistence(d, a.id);

    const approveBtn = d.querySelector('[data-act="approve"]');
    const rejectBtn = d.querySelector('[data-act="reject"]');

    approveBtn.onclick = async () => {
      try{
        approveBtn.disabled = true;
        const note = prompt("Optional note for approval (leave blank for none):") || "";
        await api("/action/approve",{id:a.id,note});
        add("piper","Approved.");
        await speak("Approved.");
        refreshActions(true);
      }catch(e){
        alert("Approve failed: "+e);
      }finally{
        approveBtn.disabled = false;
      }
    };

    rejectBtn.onclick = async () => {
      try{
        rejectBtn.disabled = true;
        const note = prompt("Why reject this action?") || "";
        await api("/action/reject",{id:a.id,note});
        add("piper","Rejected.");
        await speak("Rejected.");
        refreshActions(true);
      }catch(e){
        alert("Reject failed: "+e);
      }finally{
        rejectBtn.disabled = false;
      }
    };

    actionsList.appendChild(d);
  }
}

function renderHistory(list){
  historyList.innerHTML = "";
  for(const a of list){
    const d = document.createElement("div");
    d.className = "card card-small";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const note = a.note ? a.note : "";

    const canPreview = ["apply_patch","write_file","mkdir","bundle","set_html_title"].includes(a.type);
    const previewHref = "/action/preview/" + a.id;

    const canRollback = a.status === "approved" || a.status === "done" || a.status === "failed";

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Updated: ${fmtTime(a.updatedAt || a.createdAt)}</span>
      </div>

      ${note ? `<div class="kv" style="margin-top:6px;"><span><b>Note:</b> ${esc(note)}</span></div>` : ``}

      <details data-kind="payload">
        <summary>View details</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      <div class="btnRow">
        ${canPreview ? `<a class="btn-secondary" href="${previewHref}" target="_blank" rel="noopener">Preview</a>` : ``}
        ${canRollback ? `<button class="btn-secondary" data-act="rollback">Rollback</button>` : ``}
      </div>
    `;

    hookDetailsPersistence(d, a.id);

    const rollbackBtn = d.querySelector('[data-act="rollback"]');
    if(rollbackBtn){
      rollbackBtn.onclick = async () => {
        try{
          rollbackBtn.disabled = true;
          const ok = confirm("Rollback this action?");
          if(!ok) return;

          const res = await api("/action/rollback", { id: a.id });
          const msg = res && res.ok ? "âœ… Rolled back." : "Rollback finished.";
          add("piper", msg);
          await speak(msg);
          refreshActions(true);
        }catch(e){
          alert("Rollback failed: " + e);
        }finally{
          rollbackBtn.disabled = false;
        }
      };
    }

    historyList.appendChild(d);
  }
}

let lastSig = "";

function signatureForActions(list){
  return list.map(a => `${a.id}:${a.status}:${a.updatedAt||a.createdAt}`).join("|");
}

async function refreshActions(force){
  try{
    const all = await fetchAllActions();

    const pending = all.filter(a => a.status === "pending");
    const recent = all
      .slice()
      .sort((a,b) => (b.updatedAt||b.createdAt||0) - (a.updatedAt||a.createdAt||0))
      .slice(0, 10);

    const sig = signatureForActions(pending);
    if(!force && sig === lastSig) return;
    lastSig = sig;

    renderPending(pending);
    renderHistory(recent);
  }catch(e){
    console.warn("refreshActions failed:", e);
  }
}

// ---- Chat ----
async function sendToChat(text){
  return await api("/chat", {
    sessionId,
    message: text,
    readOnly: readOnly.checked,
    userInitiated: true,
  });
}

f.onsubmit = async (e) => {
  e.preventDefault();
  const msg = t.value.trim();
  if(!msg) return;

  t.value = "";
  add('me', msg);

  const thinkingNode = add('piper', 'ðŸ§  Thinkingâ€¦');

  try{
    const c = await sendToChat(msg);
    remove(thinkingNode);

    add('piper', c.reply);

    const queued = !readOnly.checked && c.proposed && Array.isArray(c.proposed) && c.proposed.length > 0;
    const speakText = queued ? "Queued for approval." : c.reply;

    await speak(speakText);

    if (queued) refreshActions(true);

  }catch(e){
    remove(thinkingNode);
    add('piper', 'âš ï¸ Something went wrong. Try again.');
    console.warn("chat failed:", e);
  }
};

off.onclick = async () => {
  const ok = confirm("Turn Piper off? (This stops the server)");
  if(!ok) return;
  try{
    off.disabled = true;
    add("piper","ðŸ›‘ Shutting downâ€¦");
    await fetch("/shutdown",{method:"POST"});
    add("piper","Server stopped. Start Piper again to use this page.");
  }catch(e){
    add("piper","Shutdown failed: "+e);
  }finally{
    off.disabled = false;
  }
};

// ðŸŽ¤ Talk: silence detection
talk.onclick = async () => {
  talk.disabled = true;
  add("piper","ðŸŽ¤ Listeningâ€¦");

  let stream, recorder, chunks=[];
  let audioCtx, analyser, data;
  let started=false, silence=0;

  const THRESH = 0.012;
  const STOP_MS = 350;
  const CHECK = 20;

  try{
    stream = await navigator.mediaDevices.getUserMedia({audio:true});
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = e => e.data.size && chunks.push(e.data);

    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    src.connect(analyser);
    data = new Uint8Array(analyser.fftSize);

    recorder.start(100);

    const iv = setInterval(()=>{
      analyser.getByteTimeDomainData(data);
      let sum=0;
      for(let i=0;i<data.length;i++){
        const v=(data[i]-128)/128; sum+=v*v;
      }
      const rms=Math.sqrt(sum/data.length);
      if(rms>THRESH) started=true;

      if(started){
        silence = rms<THRESH ? silence+CHECK : 0;
        if(silence>=STOP_MS){
          clearInterval(iv);
          recorder.stop();
        }
      }
    },CHECK);

    const blob = await new Promise(r => recorder.onstop = () => r(new Blob(chunks,{type:"audio/webm"})));

    try{ stream.getTracks().forEach(t=>t.stop()); }catch{}
    try{ audioCtx && audioCtx.close && audioCtx.close(); }catch{}

    add("piper","ðŸ“ Transcribingâ€¦");

    const fd = new FormData();
    fd.append("audio", blob, "mic.webm");
    const tr = await fetch("/voice/transcribe",{ method:"POST", body: fd });
    const tj = await tr.json().catch(()=>null);
    const text = tj && tj.ok ? tj.text : "";
    if(!text){
      add("piper","âš ï¸ No transcript.");
      return;
    }

    add("me", text, "voice");
    const thinkingNode = add("piper","ðŸ§  Thinkingâ€¦");

    const c = await sendToChat(text);
    remove(thinkingNode);

    add("piper", c.reply);

    const queued = !readOnly.checked && c.proposed && Array.isArray(c.proposed) && c.proposed.length > 0;
    const speakText = queued ? "Queued for approval." : c.reply;

    await speak(speakText);

    if (queued) refreshActions(true);

  }catch(e){
    console.warn("talk flow failed:", e);
    add("piper","âš ï¸ Voice input failed. Check console.");
  }finally{
    talk.disabled = false;
  }
};

// Boot
initVoiceUI();
refreshActions(true);
setInterval(()=>refreshActions(false), 1200);
</script>
</body>
</html>
