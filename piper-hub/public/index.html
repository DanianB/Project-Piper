<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Piper Hub</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Piper</h1>
        <div class="sub">
          <span>Local assistant</span>
          <a href="/ping" target="_blank" rel="noopener">/ping</a>
        </div>
      </div>

      <div class="pills">
        <label class="pill">
          <input id="readOnly" type="checkbox" />
          <span>Read-only</span>
        </label>

        <button id="talk" class="btn-primary">üé§ Talk</button>
        <button id="off" class="btn-danger">üõë Off</button>
      </div>
    </div>

    <div class="panel">
      <div id="log"></div>

      <form id="f">
        <input id="t" type="text" placeholder="Type a message‚Ä¶" autocomplete="off" />
        <button class="btn-primary">Send</button>
      </form>
    </div>

    <div id="actionsWrap" class="section panel" style="display:none">
      <div class="sectionHeader">
        <h3>Pending Actions</h3>
        <div class="hint">Approve to execute. Preview shows what will change.</div>
      </div>
      <div id="actionsList"></div>
    </div>

    <div id="history" class="section panel">
      <details open>
        <summary class="sectionSummary">
          <span style="font-weight:700">Recent Actions</span>
          <span class="hint">Latest 10</span>
        </summary>
        <div id="historyList"></div>
      </details>
    </div>
  </div>

<script>
const log = document.getElementById('log');
const f = document.getElementById('f');
const t = document.getElementById('t');
const talk = document.getElementById('talk');
const off = document.getElementById('off');
const readOnly = document.getElementById('readOnly');

const actionsWrap = document.getElementById("actionsWrap");
const actionsList = document.getElementById("actionsList");
const historyList = document.getElementById("historyList");

const sessionId = localStorage.getItem("piper_sessionId") || (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
localStorage.setItem("piper_sessionId", sessionId);

// Persist <details> open state per action id
const openDetails = new Set(JSON.parse(localStorage.getItem("piper_openDetails") || "[]"));

function hookDetailsPersistence(cardEl, actionId){
  const details = cardEl.querySelectorAll("details[data-kind]");
  details.forEach(d => {
    const key = `${actionId}:${d.getAttribute("data-kind")}`;
    if(openDetails.has(key)) d.open = true;

    d.addEventListener("toggle", () => {
      if(d.open) openDetails.add(key);
      else openDetails.delete(key);
      localStorage.setItem("piper_openDetails", JSON.stringify(Array.from(openDetails)));
    }, { passive: true });
  });
}

function signatureForActions(list){
  return list.map(a => `${a.id}:${a.status}:${a.updatedAt||a.createdAt}`).join("|");
}
function badgeClass(status){
  return ["pending","running","done","failed","rejected","rolled_back","approved"].includes(status) ? status : "pending";
}
function fmtTime(ms){
  try { return new Date(ms).toLocaleString(); } catch { return ""; }
}
function esc(s){ return String(s).replaceAll("<","&lt;"); }

function add(who, msg, meta){
  const row = document.createElement('div');
  row.className = 'msg ' + who;

  const whoEl = document.createElement('div');
  whoEl.className = 'who';
  whoEl.textContent = who === 'me' ? 'You' : 'Piper';

  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  bubble.innerHTML = String(msg).replaceAll('\n','<br>');

  if(meta){
    const m = document.createElement('div');
    m.className = 'metaLine';
    m.textContent = meta;
    bubble.appendChild(m);
  }

  row.appendChild(whoEl);
  row.appendChild(bubble);
  log.appendChild(row);
  log.scrollTop = log.scrollHeight;

  // ‚úÖ return DOM node so we can remove/replace ‚ÄúThinking‚Ä¶‚Äù
  return row;
}

function remove(node){
  try{ node && node.remove && node.remove(); }catch{}
}

async function api(path, body){
  const r = await fetch(path,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body||{})
  });
  const j = await r.json().catch(()=>null);
  if(!r.ok) throw new Error((j && (j.error||j.message)) || (r.status+" "+r.statusText));
  return j;
}

function renderPending(pending){
  actionsWrap.style.display = pending.length ? "block" : "none";
  actionsList.innerHTML = "";

  for(const a of pending){
    const d = document.createElement("div");
    d.className = "card";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const reason = a.reason ? a.reason : "";

    // ‚úÖ include set_html_title so title edits can show preview
    const canPreview = ["apply_patch","write_file","mkdir","bundle","set_html_title"].includes(a.type);

    const previewHref = "/action/preview/" + a.id;

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Created: ${fmtTime(a.createdAt)}</span>
      </div>

      ${reason ? `<div class="kv" style="margin-top:6px;"><span><b>Why:</b> ${esc(reason)}</span></div>` : ``}

      <details data-kind="payload">
        <summary>View details</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      <div class="btns">
        ${canPreview ? `<a class="previewLink" href="${previewHref}" target="_blank" rel="noopener">üîé Preview</a>` : `<span class="previewDisabled">No preview</span>`}
        <button class="btn-primary" data-approve="${a.id}">‚úÖ Approve</button>
        <button class="btn-danger" data-reject="${a.id}">‚ùå Reject</button>
      </div>
    `;

    hookDetailsPersistence(d, a.id);

    d.querySelector("[data-approve]").onclick = async () => {
      if(!confirm("Approve and execute this action?")) return;

      const btn = d.querySelector("[data-approve]");
      btn.disabled = true;

      add("piper","üõ† Executing approved action‚Ä¶");

      async function waitForPing(timeoutMs = 15000){
        const t0 = Date.now();
        while(Date.now() - t0 < timeoutMs){
          try{
            const r = await fetch("/ping", { cache: "no-store" });
            if(r.ok) return true;
          }catch{}
          await new Promise(r => setTimeout(r, 500));
        }
        return false;
      }

      try{
        const out = await api("/action/approve",{ id: a.id });

        add("piper", out.action?.status==="done" ? "‚úÖ Done." : "‚ö†Ô∏è Failed. Check details.");

        // restart/off may drop connection
        if ((out.action?.type || a.type) === "restart_piper") {
          add("piper","üîÅ Restarting‚Ä¶");
          const ok = await waitForPing();
          add("piper", ok ? "‚úÖ Back online." : "‚ö†Ô∏è Still offline. Check the supervisor window.");
        }
        if ((out.action?.type || a.type) === "shutdown_piper") {
          add("piper","üõë Powered down.");
        }

      }catch(e){
        if (a.type === "restart_piper") {
          add("piper","üîÅ Restarting‚Ä¶ (connection dropped ‚Äî expected)");
          const ok = await waitForPing();
          add("piper", ok ? "‚úÖ Back online." : "‚ö†Ô∏è Still offline. Check the supervisor window.");
        } else if (a.type === "shutdown_piper") {
          add("piper","üõë Powered down.");
        } else {
          add("piper","‚ö†Ô∏è Execute failed: " + e);
        }
      }finally{
        btn.disabled = false;
        refreshActions(true);
      }
    };

    d.querySelector("[data-reject]").onclick = async () => {
      const note = prompt("Reject note (optional):") || "";
      try{
        await api("/action/reject",{id:a.id,note});
        add("piper","Rejected.");
        try{
          await fetch('/voice/speak',{
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({text:"Rejected."})
          });
        }catch{}
        refreshActions(true);
      }catch(e){
        add("piper","‚ö†Ô∏è Reject failed: "+e);
      }
    };

    actionsList.appendChild(d);
  }
}

function renderHistory(list){
  historyList.innerHTML = "";
  const recent = list.filter(a => a.status!=="pending").slice(0, 10);

  for(const a of recent){
    const d = document.createElement("div");
    d.className = "card subtle";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const resultPretty = a.result ? JSON.stringify(a.result, null, 2) : "";
    const canRollback =
      ["write_file","apply_patch"].includes(a.type) &&
      ["done","failed"].includes(a.status);

    // ‚úÖ include set_html_title so title edits can show preview in history too
    const canPreview = ["apply_patch","write_file","mkdir","bundle","set_html_title"].includes(a.type);

    const previewHref = "/action/preview/" + a.id;

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Updated: ${fmtTime(a.updatedAt || a.createdAt)}</span>
      </div>

      <details data-kind="payload">
        <summary>Payload</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      ${resultPretty ? `
        <details data-kind="result">
          <summary>Result</summary>
          <pre>${esc(resultPretty)}</pre>
        </details>
      ` : ``}

      <div class="btns">
        ${canPreview ? `<a class="previewLink" href="${previewHref}" target="_blank" rel="noopener">üîé Preview</a>` : ``}
        ${canRollback ? `<button class="btn-secondary" data-rollback="${a.id}">‚Ü© Rollback</button>` : ``}
      </div>
    `;

    hookDetailsPersistence(d, a.id);

    const rb = d.querySelector("[data-rollback]");
    if(rb){
      rb.onclick = async () => {
        if(!confirm("Rollback this action? (Restores from backup when possible)")) return;
        add("piper","‚Ü© Attempting rollback‚Ä¶");
        try{
          const out = await api("/action/rollback",{id:a.id});
          const msg = out.action?.status==="rolled_back" ? "‚úÖ Rolled back." : "Rollback finished.";
          add("piper", msg);
          try{
            await fetch('/voice/speak',{
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body:JSON.stringify({text: msg})
            });
          }catch{}
          refreshActions(true);
        }catch(e){
          add("piper","‚ö†Ô∏è Rollback failed: "+e);
        }
      };
    }

    historyList.appendChild(d);
  }
}

let lastActionsSignature = "";

async function refreshActions(force=false){
  try{
    const r = await fetch("/actions");
    if(!r.ok) return;
    const j = await r.json();
    if(!(j && j.ok && Array.isArray(j.actions))) return;

    const list = j.actions;
    const sig = signatureForActions(list);
    if(!force && sig === lastActionsSignature) return;
    lastActionsSignature = sig;

    renderPending(list.filter(a => a.status==="pending"));
    renderHistory(list);
  }catch{}
}

// Poll
setInterval(() => refreshActions(false), 2500);
refreshActions(true);

async function sendToChat(message, { timeoutMs = 60000 } = {}){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);

  try{
    const r = await fetch('/chat',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({ sessionId, message, readOnly: readOnly.checked }),
      signal: controller.signal
    });

    if(!r.ok){
      const txt = await r.text().catch(()=>"(no body)");
      add('piper','‚ö†Ô∏è /chat error: '+r.status+' '+txt);
      throw new Error('chat failed');
    }
    return await r.json();

  }catch(e){
    if(e && e.name === "AbortError"){
      add('piper', `‚ö†Ô∏è /chat timed out after ${timeoutMs/1000}s. (Ollama/server stalled)`);
    } else {
      add('piper', '‚ö†Ô∏è /chat failed: ' + e);
    }
    throw e;

  }finally{
    clearTimeout(timer);
  }
}

f.onsubmit = async (e) => {
  e.preventDefault();

  const m = t.value.trim();
  if(!m) return;

  add('me', m);
  t.value = '';

  const thinkingNode = add('piper', 'üß† Thinking‚Ä¶');

  try{
    const c = await sendToChat(m);
    remove(thinkingNode);

    add('piper', c.reply);

    const queued = !readOnly.checked && c.proposed && Array.isArray(c.proposed) && c.proposed.length > 0;
    const speakText = queued ? "Queued for approval." : c.reply;

    try{
      await fetch('/voice/speak',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ text: speakText })
      });
    }catch{}

    // If actions were queued, refresh immediately so you see them.
    if (queued) refreshActions(true);

  }catch{
    remove(thinkingNode);
    add('piper', '‚ö†Ô∏è Something went wrong. Try again.');
  }
};

off.onclick = async () => {
  const ok = confirm("Turn Piper off? (This stops the server)");
  if(!ok) return;
  try{
    off.disabled = true;
    add("piper","üõë Shutting down‚Ä¶");
    await fetch("/shutdown",{method:"POST"});
    add("piper","Server stopped. Start Piper again to use this page.");
  }catch(e){
    add("piper","Shutdown failed: "+e);
  }finally{
    off.disabled = false;
  }
};

// üé§ Talk: silence detection
talk.onclick = async () => {
  talk.disabled = true;
  add("piper","üé§ Listening‚Ä¶");

  let stream, recorder, chunks=[];
  let audioCtx, analyser, data;
  let started=false, silence=0;

  const THRESH = 0.012;
  const STOP_MS = 350;
  const CHECK = 20;

  try{
    stream = await navigator.mediaDevices.getUserMedia({audio:true});
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = e => e.data.size && chunks.push(e.data);

    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    src.connect(analyser);
    data = new Uint8Array(analyser.fftSize);

    recorder.start(100);

    const iv = setInterval(()=>{
      analyser.getByteTimeDomainData(data);
      let sum=0;
      for(let i=0;i<data.length;i++){
        const v=(data[i]-128)/128; sum+=v*v;
      }
      const rms=Math.sqrt(sum/data.length);
      if(rms>THRESH) started=true;

      if(started){
        silence = rms<THRESH ? silence+CHECK : 0;
        if(silence>=STOP_MS){
          clearInterval(iv);
          recorder.stop();
        }
      }
    },CHECK);

    const blob = await new Promise(r => recorder.onstop = () => r(new Blob(chunks,{type:"audio/webm"})));

    try{ stream.getTracks().forEach(t=>t.stop()); }catch{}
    try{ audioCtx && audioCtx.close && audioCtx.close(); }catch{}

    add("piper","üìù Transcribing‚Ä¶");

    const fd = new FormData();
    fd.append("audio", blob, "mic.webm");
    const tr = await fetch("/voice/transcribe",{ method:"POST", body: fd });
    const tj = await tr.json().catch(()=>null);
    const text = tj && tj.ok ? tj.text : "";
    if(!text){
      add("piper","‚ö†Ô∏è No transcript.");
      return;
    }

    add("me", text, "voice");
    const thinkingNode = add("piper","üß† Thinking‚Ä¶");

    const c = await sendToChat(text);
    remove(thinkingNode);

    add("piper", c.reply);

    const queued = !readOnly.checked && c.proposed && Array.isArray(c.proposed) && c.proposed.length > 0;
    const speakText = queued ? "Queued for approval." : c.reply;

    try{
      await fetch('/voice/speak',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ text: speakText })
      });
    }catch{}

    if (queued) refreshActions(true);

  }catch(e){
    add("piper","‚ö†Ô∏è Mic failed: "+e);
  }finally{
    talk.disabled = false;
  }
};
</script>
</body>
</html>
