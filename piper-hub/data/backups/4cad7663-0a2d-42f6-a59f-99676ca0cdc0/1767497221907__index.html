<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Piper</title>
  <link rel="stylesheet" href="/styles.css?v=2">
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Piper</h1>
        <div class="sub">
          <span>Ping: <a href="/ping" target="_blank">/ping</a></span>
          <span>Devices: <a href="/devices" target="_blank">/devices</a></span>
          <span>Actions: <a href="/actions" target="_blank">/actions</a></span>
          <span>Apps: <code>data/apps.json</code></span>
        </div>
      </div>

      <div class="pills">
        <label class="pill" title="When enabled, Piper will propose actions for your approval.">
          <input type="checkbox" id="devMode">
          Dev Mode
        </label>
      </div>
    </div>

    <div class="panel" id="log"></div>

    <div class="panel section" id="actions" style="display:none;">
      <div class="sectionHeader">
        <h3>Pending Actions</h3>
        <div class="hint">Nothing runs without approval.</div>
      </div>
      <div id="actionsList"></div>
    </div>

    <div class="panel section" id="history">
      <div class="sectionHeader">
        <h3>Recent Actions</h3>
        <div class="hint">Done / failed / rejected.</div>
      </div>
      <div id="historyList"></div>
    </div>

    <div class="panel">
      <form id="f">
        <input id="t" type="text" placeholder="Type to Piper..." autocomplete="off">
        <button class="btn-primary" type="submit">Send</button>
        <button type="button" id="talk">üé§ Talk</button>
        <button class="btn-danger" type="button" id="off" title="Stop Piper server">‚èª Off</button>
      </form>
    </div>
  </div>

<script>
const log=document.getElementById('log');
const f=document.getElementById('f');
const t=document.getElementById('t');
const talk=document.getElementById('talk');
const off=document.getElementById('off');

const actionsWrap=document.getElementById('actions');
const actionsList=document.getElementById('actionsList');
const historyList=document.getElementById('historyList');

const devMode = document.getElementById('devMode');
devMode.checked = localStorage.getItem("piperDevMode")==="1";
devMode.onchange = () => localStorage.setItem("piperDevMode", devMode.checked ? "1" : "0");

const sessionId=localStorage.getItem('piperSession')||crypto.randomUUID();
localStorage.setItem('piperSession',sessionId);

// -----------------------
// Persist <details> state across polling re-renders
// -----------------------
const openDetails = new Set();
// Avoid rerenders if nothing changed
let lastActionsSignature = "";

function detailsKey(actionId, kind){
  return `${actionId}::${kind}`;
}

function hookDetailsPersistence(rootEl, actionId){
  rootEl.querySelectorAll("details[data-kind]").forEach(dt => {
    const kind = dt.getAttribute("data-kind") || "details";
    const key = detailsKey(actionId, kind);

    // Restore
    dt.open = openDetails.has(key);

    // Track changes
    dt.addEventListener("toggle", () => {
      if(dt.open) openDetails.add(key);
      else openDetails.delete(key);
    }, { passive: true });
  });
}

function signatureForActions(list){
  return list.map(a => `${a.id}:${a.status}:${a.updatedAt||a.createdAt}`).join("|");
}

function badgeClass(status){
  return ["pending","running","done","failed","rejected","rolled_back","approved"].includes(status) ? status : "pending";
}
function fmtTime(ms){
  try { return new Date(ms).toLocaleString(); } catch { return ""; }
}
function esc(s){ return String(s).replaceAll("<","&lt;"); }

function add(who,msg,meta){
  const row=document.createElement('div');
  row.className='msg '+who;

  const whoEl=document.createElement('div');
  whoEl.className='who';
  whoEl.textContent = who==='me' ? 'You' : 'Piper';

  const bubble=document.createElement('div');
  bubble.className='bubble';
  bubble.innerHTML = String(msg).replaceAll('\n','<br>');

  if(meta){
    const m=document.createElement('div');
    m.className='metaLine';
    m.textContent = meta;
    bubble.appendChild(m);
  }

  row.appendChild(whoEl);
  row.appendChild(bubble);

  log.appendChild(row);
  log.scrollTop=log.scrollHeight;
}

async function api(path, body){
  const r = await fetch(path,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body||{})
  });
  const j = await r.json().catch(()=>null);
  if(!r.ok) throw new Error((j && (j.error||j.message)) || (r.status+" "+r.statusText));
  return j;
}

function renderPending(pending){
  actionsWrap.style.display = pending.length ? "block" : "none";
  actionsList.innerHTML = "";

  for(const a of pending){
    const d = document.createElement("div");
    d.className = "card";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const reason = a.reason ? a.reason : "";

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Created: ${fmtTime(a.createdAt)}</span>
      </div>

      ${reason ? `<div class="kv" style="margin-top:6px;"><span><b>Why:</b> ${esc(reason)}</span></div>` : ``}

      <details data-kind="payload">
        <summary>View details</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      <div class="btns">
        <button class="btn-primary" data-approve="${a.id}">‚úÖ Approve</button>
        <button class="btn-danger" data-reject="${a.id}">‚ùå Reject</button>
      </div>
    `;

    // Restore + persist <details> open state
    hookDetailsPersistence(d, a.id);

    d.querySelector("[data-approve]").onclick = async () => {
      if(!confirm("Approve and execute this action?")) return;
      add("piper","üõ† Executing approved action‚Ä¶");
      try{
        const out = await api("/action/approve",{id:a.id});

const msg =
  out.action?.status==="done" ? "‚úÖ Done." :
  out.action?.status==="failed" ? "‚ö†Ô∏è Failed. See Recent Actions for details." :
  "Done.";

add("piper", msg);

// Speak the actual outcome now (this is the truthful moment)
await fetch('/voice/speak',{
  method:'POST',
  headers:{'Content-Type':'application/json'},
  body:JSON.stringify({text: out.action?.status==="done" ? "Done." : "That failed."})
});

refreshActions(true);

      }catch(e){
        add("piper","‚ö†Ô∏è Execute failed: "+e);
      }
    };

    d.querySelector("[data-reject]").onclick = async () => {
      const note = prompt("Reject note (optional):") || "";
      try{
        await api("/action/reject",{id:a.id,note});
add("piper","Rejected.");

await fetch('/voice/speak',{
  method:'POST',
  headers:{'Content-Type':'application/json'},
  body:JSON.stringify({text:"Rejected."})
});

refreshActions(true);

      }catch(e){
        add("piper","‚ö†Ô∏è Reject failed: "+e);
      }
    };

    actionsList.appendChild(d);
  }
}

function renderHistory(list){
  historyList.innerHTML = "";
  const recent = list.filter(a => a.status!=="pending").slice(0, 10);

  for(const a of recent){
    const d = document.createElement("div");
    d.className = "card subtle";

    const payloadPretty = JSON.stringify(a.payload || {}, null, 2);
    const resultPretty = a.result ? JSON.stringify(a.result, null, 2) : "";
    const canRollback =
      ["write_file","apply_patch","move_file","delete_file"].includes(a.type) &&
      ["done","failed"].includes(a.status);

    d.innerHTML = `
      <h4>
        <span>${esc(a.title || a.type)}</span>
        <span class="badge ${badgeClass(a.status)}">${esc(a.status)}</span>
      </h4>

      <div class="kv">
        <span>Type: <code>${esc(a.type)}</code></span>
        <span>Updated: ${fmtTime(a.updatedAt || a.createdAt)}</span>
      </div>

      <details data-kind="payload">
        <summary>Payload</summary>
        <pre>${esc(payloadPretty)}</pre>
      </details>

      ${resultPretty ? `
        <details data-kind="result">
          <summary>Result</summary>
          <pre>${esc(resultPretty)}</pre>
        </details>
      ` : ``}

      <div class="btns">
        ${canRollback ? `<button class="btn-secondary" data-rollback="${a.id}">‚Ü© Rollback</button>` : ``}
      </div>
    `;

    // Restore + persist <details> open state
    hookDetailsPersistence(d, a.id);

    const rb = d.querySelector("[data-rollback]");
    if(rb){
      rb.onclick = async () => {
        if(!confirm("Rollback this action? (Restores from backup/trash when possible)")) return;
        add("piper","‚Ü© Attempting rollback‚Ä¶");
        try{
            const out = await api("/action/rollback",{id:a.id});

const msg = out.action?.status==="rolled_back" ? "‚úÖ Rolled back." : "Rollback finished.";
add("piper", msg);

await fetch('/voice/speak',{
  method:'POST',
  headers:{'Content-Type':'application/json'},
  body:JSON.stringify({text: out.action?.status==="rolled_back" ? "Rolled back." : "Rollback finished."})
});

refreshActions(true);

        }catch(e){
          add("piper","‚ö†Ô∏è Rollback failed: "+e);
        }
      };
    }

    historyList.appendChild(d);
  }
}

async function refreshActions(force=false){
  try{
    const r = await fetch("/actions");
    if(!r.ok) return;
    const j = await r.json();
    if(!(j && j.ok && Array.isArray(j.actions))) return;

    const list = j.actions;
    const sig = signatureForActions(list);
    if(!force && sig === lastActionsSignature) return; // nothing changed
    lastActionsSignature = sig;

    renderPending(list.filter(a => a.status==="pending"));
    renderHistory(list);
  }catch{}
}

// Poll for actions (less aggressive + stable)
setInterval(() => refreshActions(false), 2500);
refreshActions(true);

async function sendToChat(message){
  const r=await fetch('/chat',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({sessionId,message, devMode: devMode.checked})
  });
  if(!r.ok){
    const txt=await r.text();
    add('piper','‚ö†Ô∏è /chat error: '+r.status+' '+txt);
    throw new Error('chat failed');
  }
  return r.json();
}

f.onsubmit=async(e)=>{
  e.preventDefault();
  const m=t.value.trim();
  if(!m) return;
  add('me',m);
  t.value='';
  add('piper','üß† Thinking‚Ä¶');

  const c=await sendToChat(m);
  add('piper',c.reply);

  // FIX: If Dev Mode queued actions, don't speak "success" yet.
  // Speak a neutral line until you approve/execute.
  const queued = devMode.checked && c.proposed && Array.isArray(c.proposed) && c.proposed.length > 0;

  const speakText = queued ? "Queued for approval." : c.reply;

  await fetch('/voice/speak',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({text:speakText})
  });
};


off.onclick = async () => {
  const ok = confirm("Turn Piper off? (This stops the server)");
  if (!ok) return;
  try{
    off.disabled=true;
    add("piper","üõë Shutting down‚Ä¶");
    await fetch("/shutdown",{method:"POST"});
    add("piper","Server stopped. Start Piper again to use this page.");
  }catch(e){
    add("piper","Shutdown failed: "+e);
  }finally{
    off.disabled=false;
  }
};

// üé§ Talk: silence detection
talk.onclick = async () => {
  talk.disabled = true;
  add("piper","üé§ Listening‚Ä¶");

  let stream, recorder, chunks=[];
  let audioCtx, analyser, data;
  let started=false, silence=0;

  // TUNING
  const THRESH = 0.012;
  const STOP_MS = 350;
  const CHECK = 20;

  try{
    stream=await navigator.mediaDevices.getUserMedia({audio:true});
    recorder=new MediaRecorder(stream);
    recorder.ondataavailable=e=>e.data.size&&chunks.push(e.data);

    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const src=audioCtx.createMediaStreamSource(stream);
    analyser=audioCtx.createAnalyser();
    analyser.fftSize=2048;
    src.connect(analyser);
    data=new Uint8Array(analyser.fftSize);

    recorder.start(100);

    const iv=setInterval(()=>{
      analyser.getByteTimeDomainData(data);
      let sum=0;
      for(let i=0;i<data.length;i++){
        const v=(data[i]-128)/128; sum+=v*v;
      }
      const rms=Math.sqrt(sum/data.length);
      if(rms>THRESH) started=true;

      if(started){
        silence = rms<THRESH ? silence+CHECK : 0;
        if(silence>=STOP_MS){
          clearInterval(iv);
          recorder.stop();
        }
      }
    },CHECK);

    const blob=await new Promise(r=>recorder.onstop=()=>r(new Blob(chunks,{type:recorder.mimeType})));

    try{ stream.getTracks().forEach(tr=>tr.stop()); }catch{}
    try{ await audioCtx.close(); }catch{}

    add("piper","üß† Thinking‚Ä¶");

    const fd=new FormData();
    fd.append("audio",blob,"speech.webm");
    const r=await fetch("/voice/transcribe",{method:"POST",body:fd});
    const j=await r.json();

    if(!j.ok){
      add("piper","Transcribe error: "+JSON.stringify(j));
      return;
    }

    if(j.raw && j.raw!==j.text) add("me", j.raw + "\n‚Üí " + j.text);
    else add("me", j.text);

    if(j.convertMs!=null && j.whisperMs!=null){
      add("piper","‚è± convert "+j.convertMs+"ms, whisper "+j.whisperMs+"ms");
    }

    const c=await sendToChat(j.text);
    add("piper",c.reply);

    await fetch('/voice/speak',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({text:c.reply})
    });

  }catch(e){
    add("piper","Voice error: "+e);
  }finally{
    talk.disabled=false;
  }
};

add('piper',"Online.");
</script>
</body>
</html>
